# 특수 숫자

### NaN

- 수학 연산 시 두 피연산자가 전부 숫자가 아닐 경우 유효한 숫자가 나올 수 없으므로 그 결과는 NaN (Not A Number)이다. 그러나 이 명칭은 오해의 소지가 다분하다. 실제로 NaN은 '숫자가 아니다'라고 표현하기 보다 '유효하지 않은 숫자', '연산에 실패한 숫자' 등의 표현이 정확하다. 아래에서 볼 수 있듯 '숫자다 아니다'의 타입은 숫자이기 때문이다.

```jsx
const x = 10 / 'foo'; // NaN
typeof x === 'number'; // true
```

- NaN 의 문제는 여기서 끝이 아니다. 어떤 변수가 NaN인지를 확인하기 위해 비교연산자를 사용하면 어떻게될까.

```jsx
const x = 10 / 'foo'; // NaN
x == NaN; // false
x === NaN; // false
NaN !== NaN; // true
```

- NaN은 반사성이 없는 (x === x 로 식별되지 않는) 유일무이한 값이다. 그렇다면 어떻게 비교해야할까. 이를 위해 isNaN이 존재한다.

```jsx
const x = 10 / 'foo';
isNaN(x); // true
```

- 하지만 이 또한 문제가 있다. 이 함수는 특이하게 '숫자가 아니다'를 글자 그대로 해석한다. 즉 인자가 숫자인지 여부를 평가한다.

```jsx
const x = 'foo';
isNaN(x); // true
```

- "foo"는 숫자가 아니지만 NaN 도 아니다. 하지만 결과는 true이다. 이 버그는 JS가 탄생된 이후 수정되지 못했다.

- 이를 해결하기 위해 ES6 부터 Number.isNaN( )이 등장했다. 이를 통해 안전하게 NaN 여부를 판단할 수 있게 되었다. 만일 폴리필이 필요하다면 아래와 같이 사용할 수 있다.

```jsx
if (!Number.isNaN) {
  Number.isNaN = function (n) {
    return n !== n;
  };
}

const x = 'foo';
Number.isNaN(x); // false
```

- 위 코드는 NaN이 자기 자신과도 동등하지 않은 특성을 사용하여 간단하게 폴리필을 구현한 것이다.

### 무한대

- 이번에 알마볼 특수 숫자는 무한대이다. 자바스크립트에서는 0으로 나눌 경우 에러를 출력하지 않고 Infinity라는 결과값이 나온다. 음수의 경우 -Infinity 를 볼 수 있다. 나누기 외에도 자바스크립트는 유한 숫자 표현식(IEEE 754 부동 소수점)을 사용하므로 덧셈과 뺄셈에서도 무한대를 볼 수 있다.

- IEEE 754 명세에 따르면 연산 결과가 너무 커서 표현하기 곤란할 때 Round-To-Nearest 모드가 결괏값을 정한다. 이를 통해 무한대를 확인해보기 위해 자바스크립트가 표현할 수 있는 가장 큰 숫자인 2^1024를 활용해보자.

```jsx
const x = Number.MAX_VALUE; // 1.7976931348623157e+308
x + x; // Infinity
x + Math.pow(2, 970); // Infinity
x + 999; // 1.7976931348623157e+308
```

- 2^970은 무한대에 가깝기 때문에 올림처리 되었고, 그 아래의 숫자는 버림처리되었다

- 하지만 한번 무한이 된 숫자는 그 어떤 숫자를 연산시키더라도 무한에서 돌아오지 못한다. 게다가 무한을 무한으로 나누면 자바스크립트에서 정의된 연산이 아니기때문에 NaN 이 결과값으로 나오게 된다.

- 그러나 양수를 무한대로 나누면 0이 된다.

### 0 (Zero)

- 위의 글에 이어 음수를 무한대로 나누면 어떻게 될까? 놀랍게도 -0 이다. 이는 비단 무한대에서만 일어나는 일이 아니다.

```jsx
const x = 0 / -10 // -0
const y = 0 \* -20 // -0
```

- 덧셈과 뺄셈에는 -0이 나오지 않는다.(IE는 아예 나오지 않는다...)

- 대체 -0은 무엇일까. 이는 문자열로 바꿀경우 "0" 이 되긴 한다. 심지어 비교연산에서도 0과 같다는 결과가 나온다. -0은 값의 크기로 어떤 정보와 그 값의 부호로 또 다른 정보를 동시에 나타내야 하는 경우 사용한다. 어떤 변숫값이 0에 도달하여 부호가 바뀌는 순간, 그 직전까지 이 변수의 이동방향이 필요하다는 의미이다. 즉, 잠재적인 정보소실을 방지하기 위해 부호가 있는 것이다.

- 지금까지 봐왔던 NaN, 0, -0 등을 비교하는 특이한 동등 비교 상황에는 Object.is 를 사용하면 좋다.

```jsx
const x = 10 / "foo"; // NaN
const y = -10 \* 0; // -0

Object.is(x, NaN); // true
Object.is(y, -0); // true
Object.is(y, 0); // false
```
